\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{anysize}
\usepackage{hyperref}
\usepackage{SIunits}
\usepackage{color}

\marginsize{2.5cm}{2.5cm}{1.5cm}{1.5cm}
\setlength{\parindent}{0pt}

\graphicspath{{./images/}}

\title{P\&D Encryption---Phase Two}
\author{Pieter Maene en Stijn Meul}
\date{\today}

\begin{document}
\maketitle

\section{Key Exchange and Authentication}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & SEQ NR & LENGTH & KEY + SIGNATURE \\ \hline
            1B & 4B & 1B & 128B + 32B (1) \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Data Packet}
\end{table}

\section{Key Derivation}

STS will result in a long RSA key at both sides (because RSA is based on the factorisation of large primes). However, for AES and the hash-functions, we need keys that are a lot shorter. To find these, we can simply chop the long RSA key in two and subsequently hash these two parts using a non-keyed hash function. In doing this, we obtain two shorter keys that are derived from the longer one. Because hashing is a one-way process, it will be impossible to reconstruct the negotiated session key from the derived keys.\\

Furthermore, this process is deterministic. So when we do the same operations on the same negotiated session key at both the sender and receiver, we will obtain the same encryption and hashing keys. This is important, because otherwise it would be impossible to verify the identity or decrypt the received data.\\

\section{Confidentiality and Integrity}

\subsection{Cipher Mode}

The performance of several AES modes is listed on the following page: \url{http://www.cryptopp.com/benchmarks.html}. These processors are not the DSPs we are going to use are not the ones mentioned on the benchmark page, but it gives an idea which algorithm has an intrinsic better performance. From this data and what we learned during the previous phase, we decided to use the CTR mode because it's the fastest. The set-up and IV initialisation times are a bit longer than for other modes, but this is not really a problem: the IV initilisation (which has to be redone for every packet) is neglible in this time. This means we the main drawback is that we will have a setup penalty on the order on one {\micro\second} for each session.\\

We decided on 128-bit keys because this is the smallest length defined by the NIST standard and is still higher than our required security level of 80 bits.

\subsection{HMAC}

We use to following formula to calculate the HMAC.

\subsubsection{Hash Function}



\subsection{Data Packet}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & SEQ NR & LENGTH & DATA & HMAC \\ \hline
            1B & 4B & 2B & (1) & 20B (2) \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Data Packet}
\end{table}

\begin{itemize}
  \item (1) The length depends on what the speech groups tell us. The larger the packet, the bigger the influence of a dropped packet on the received audio, so this is a limiting factor. A good reference is the size of an Ethernet frame, which is 1500 bytes (for the entire packet).
  \item (2) For the HMAC, we will calculate the keyed hash of the entire packet (except for the HMAC field itself, of course). We will use a keyed SHA-3 hash here as well, truncated to 20 bytes which is the minimum required length for 80-bit security.
\end{itemize}

The SEQ NR is a 32-bit counter so that it will not be likely that there is wrap-around in a single session. The duration of the session obviously depends on the length of the complete packet as well. If a 1000 bytes frame would be used, this would correspond to a duration of 0.26 seconds. Using a 32-bit counter would then correspond to a session duration of several days. The maximum size of the sequence number is recommended to be 32-bit as it is the maximum workable word size to create counters in. A bigger sequence number would require a double which would make the code more bulky and the performance less efficient as every time 2 words need to be fetched.\\

We note that it might be possible that we will not even need the length field at all. If the speech buffer is always full when we send the packet, the length will be constant and the receiving side can use this information. In this situation, the packet rate is not constant. However, if the data length is variable (for example because we send packets at a constant rate, regardless of whether or not we have a full buffer), the length field will be required to signal to the receiver how much data is present in the packet.

\end{document}