\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{anysize}
\usepackage{hyperref}
\usepackage{SIunits}
\usepackage{color}

\marginsize{2.5cm}{2.5cm}{1.5cm}{1.5cm}
\setlength{\parindent}{0pt}

\graphicspath{{./images/}}

\title{P\&D Encryption---Phase Two}
\author{Pieter Maene en Stijn Meul}
\date{\today}

\begin{document}
\maketitle

\section{Key Exchange and Authentication}

\section{Key Derivation}

The result of the STS function is a very long key. The length of this key will be 2048 bit. To shorten this key with enough randomness, the key is used as the input of a hash function. The result of the hash function is then truncated to obtain a shorter more useable key.\\

SHA-3 will be used for the Hash function. The resulting keys will consequently be 512 or 1024 bits long. For performance reasons the 512 bit version is prefered. This 512 bit key is then split in four equal parts of 128 bits. The first 128 bits sequence corresponds to the first key. The second 128 bits sequence corresponds to the second key.\\

The first key can then be used as the input for the AES encryption algorithm while the second key is used as the key for the keyed hashfunction for the MAC. The reason to use different keys for the encryption and the MAC is to avoid correlation between these two parts of the packet.

\section{Confidentiality and Integrity}

\subsection{Cipher Mode}

The performance of several AES modes is listed on the following page: \url{http://www.cryptopp.com/benchmarks.html}. These processors are not the DSPs we are going to use are not the ones mentioned on the benchmark page, but it gives an idea which algorithm has an intrinsic better performance. From this data and what we learned during the previous phase, we decided to use the CTR mode because it's the fastest. The set-up and IV initialisation times are a bit longer than for other modes, but this is not really a problem: the IV initilisation (which has to be redone for every packet) is neglible in this time. This means we the main drawback is that we will have a setup penalty on the order on one {\micro\second} for each session.\\

We decided on 128-bit keys because this is the smallest length defined by the NIST standard and is still higher than our required security level of 80 bits.

\subsection{Hash Function}

We focused on two hash functions: the SHA-2 family and RIPEMD-160. We decided not to look at SHA-3 because from \url{http://bench.cr.yp.to/graph-sha3/long.png} (Keccak was chosen by NIST to become SHA-3) we learned that the performance is roughly the same as for the SHA-2 family, but with longer hashes. However, our application does not benefit from this (to achieve the 80-bit security, we need 160-bit hashes).\\

Again using the benchmark from \textit{Crypto++} we compared SHA-256 to RIPEMD-160 in terms of performance. Both offer roughly the same speeds, so the main advantage RIPEMD-160 has is the fact that's the hash is a bit shorter, leaving more room for data in the packet.\\

In the implementation phase, we try to build a generic interface to the hashing functions so that we can switch out the algorithms and compare performances. However, we will start out our implementation with SHA-2 because it is a widely used and popular hash function.

\subsection{Data Packet}

\begin{table}[h]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & SEQ NR & LENGTH & DATA & MAC \\ \hline
            1B & 4B & 2B & (1) & 32B (2) \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Data Packet}
\end{table}

\begin{itemize}
  \item (1) The length depends on what the speech groups tell us. The larger the packet, the bigger the influence of a dropped packet on the received audio, so this is a limiting factor. A good reference is the size of an Ethernet frame, which is 1500 bytes (for the entire packet).
  \item (2) For the MAC, we will calculate the keyed hash of the entire packet (except for the MAC field, of course). The size of this hash will depend on the chosen algorithm. As we discussed earlier, we are currently looking at RIPEMD-160 and SHA-2. To accomodate for both algorithms, we will decided on a 32-byte field (the size of the SHA hash, which is the largest). 
\end{itemize}

The SEQ NR is a 32-bit counter so that it will not be likely that there is wrap-around in a single session. The duration of the session obviously depends on the length of the complete packet as well. If a 1000 bytes frame would be used, this would correspond to a duration of 0.26 seconds. Using a 32-bit counter would then correspond to a session duration of several days. The maximum size of the sequence number is recommended to be 32-bit as it is the maximum workable word size to create counters in. A bigger sequence number would require a double which would make the code more bulky and the performance less efficient as every time 2 words need to be fetched.\\

We note that it might be possible that we will not even need the length field at all. If the speech buffer is always full when we send the packet, the length will be constant and the receiving side can use this information. In this situation, the packet rate is not constant. However, if the data length is variable (for example because we send packets at a constant rate, regardless of whether or not we have a full buffer), the length field will be required to signal to the receiver how much data is present in the packet.

\end{document}