\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{anysize}
\usepackage{hyperref}
\usepackage{SIunits}
\usepackage{color}

\marginsize{2.5cm}{2.5cm}{1.5cm}{1.5cm}
\setlength{\parindent}{0pt}

\graphicspath{{./images/}}

\title{P\&D Encryption---Phase Two}
\author{Pieter Maene en Stijn Meul}
\date{\today}

\begin{document}
\maketitle

\section{Key Exchange and Authentication}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & KEY & SIGNATURE \\ \hline
            1B & 256B & 20B \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Key Exchange Packet}
    \label{tab:key_exchange_packet}
\end{table}

\section{Protocol Messages}
In the Station-to-Station protocol three messages will be exchanged between the two DSPs:

\begin{enumerate}
 \item DSP A generates a random number $x$ and then sends $\alpha^x mod\ p$ to DSP B. This is shown in Table~\ref{tab:key_exchange_packet_senderhello}.
 \item DSP B generates a random number $y$ and sends $\alpha^y mod\ p$ to DSP A. B signs the concatenation of both exponentials by calculating the HMAC based on the asymmetric key of B. This is shown in Table~\ref{tab:key_exchange_packet_receiverhello}.
 \item DSP A acknowledges the message from DSP B by sending its signature to DSP B. This signature is obtained by the concatenation of both exponentials by calculating the HMAC based on the asymmetric key of A. This is shown in Table~\ref{tab:key_exchange_packet_senderacknowledge}.
\end{enumerate}
This procedure is safe because DSP A and DSP B know both their own random generated number and factorisation of large primes is a computationally intensive task. As $\alpha$ to the power of the other random number is sent, both DSPs are able to calculate $\left(\alpha^{x}\right)^{y}\mod{p} = \left(\alpha^{y}\right)^{x}\mod{p}$. These calculations are used as the shared key.

\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & KEY & SIGNATURE \\ \hline
            0x00 & $\alpha^x\mod{p}$ & \\
            \hline
        \end{tabular}
    \end{center}
    \
    \caption{Key Exchange Packet---SenderHello}
    \label{tab:key_exchange_packet_senderhello}
\end{table}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & KEY & SIGNATURE \\ \hline
            0x01 & $\alpha^y\mod{p}$ & HMAC-SHA3($\alpha^y \big| \alpha^x$)\\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Key Exchange Packet---ReceiverHello}
    \label{tab:key_exchange_packet_receiverhello}
\end{table}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & KEY & SIGNATURE \\ \hline
            0x02 & $\alpha^y\mod{p}$ & HMAC-SHA3($\alpha^x \big| \alpha^y$)\\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Key Exchange Packet---SenderAcknowledge}
    \label{tab:key_exchange_packet_senderacknowledge}
\end{table}

\section{Key Derivation}
\label{sec:key_derivation}

The result of the STS protocol is a very long key that is shared between both DSPs. The length of this key will be 2048 bit. To shorten this key with enough randomness, it is used as the input of a hash function. The result of the hash function is then truncated to obtain a shorter more useable key.\\

SHA-3 will be used as the hash function. The resulting keys will be 256 bits long. This 256-bit key is then truncated to 128 bits to generate a useable key. We then hash the previous hash and truncate this one to 80 bits.\\

The first key can then be used as the input for the AES encryption algorithm while the second key is used as the key for the keyed hash function to generate the MAC. The reason to use different keys for the encryption and the MAC is to avoid correlation between these parts of the packet.

\section{Confidentiality and Integrity}

\subsection{Cipher Mode}

The performance of several AES modes is listed on the following page: \url{http://www.cryptopp.com/benchmarks.html}. The DSPs we are going to use are not the ones mentioned on the benchmark page, but it gives an idea which algorithm has an intrinsically better performance. From this data and what we learned during the previous phase, we decided to use the CTR mode because it's the fastest. The set-up and IV initialisation times are a bit longer than for other modes, but this is not really a problem: the IV initilisation (which has to be redone for every packet) is neglible. This means the main drawback is that we will have a setup penalty on the order on one {\micro\second} for each session.\\

We decided on 128-bit keys because this is the smallest length defined by the NIST standard which is still higher than our required security level of 80 bits.

\subsection{HMAC}

We define our SHA-3 based keyed hash function as given in Equation~\ref{eq:hmac_sha3}. In this equation, $k$ is the key, $x$ the data that should be hashed and $p_1$ and $p_2$ are padding strings.

\begin{equation} \label{eq:hmac_sha3}
    \text{HMAC-SHA3}(k, x) = \text{SHA3}(k | p_1 | \text{SHA3}(k | p_2 | x))
\end{equation}

A benchmark\footnote{\url{http://bench.cr.yp.to/graph-sha3/long.png}} of the different SHA-3 finalists reveals that Keccak---the winner of the competition---has roughly the same performance as SHA-2. We will use a 256-bit hash which is defined by the standard as given in Equation~\ref{eq:keccak_256}\footnote{\url{http://keccak.noekeon.org/Keccak-submission-3.pdf}}. In this expression, $r$ is the bitrate and $c$ the capacity (the algorithm's security parameter). ${\lfloor}{\ }{\rfloor}_n$ indicates a truncation to the first n bits.

\begin{equation} \label{eq:keccak_256}
    {\lfloor}\text{Keccak}(r = 1088, c = 512){\rfloor}_{256}
\end{equation}

The input key $k$ has a length of 80 bits (see Paragraph~\ref{sec:key_derivation}). The two padding strings $p_1$ and $p_2$ are required to make sure our input data has the required length for one block of the hash function. Keccak requires a 10*1-padding pattern: a 1, followed by a number of zeroes (at most r-1) followed by a final 1.

\subsection{Data Packet}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & SEQ NR & LENGTH & DATA & HMAC \\ \hline
            1B (1) & 4B & 2B & (2) & 20B (3) \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Data Packet}
    \label{tab:data_packet}
\end{table}

The data packet can be seen in Table~\ref{tab:data_packet}. We start by giving an explanation for the choices we made:

\begin{itemize}
    \item (1) We define the TAG for this packet to be 0x03.
    \item (2) The length depends on what the speech groups tell us. The larger the packet, the bigger the influence of a dropped packet on the received audio, so this is a limiting factor. A good reference is the size of an Ethernet frame, which is 1500 bytes (for the entire packet).
    \item (3) For the HMAC, we will calculate the keyed hash of the entire packet (except for the HMAC field itself, of course). We will use a keyed SHA-3 hash here as well, truncated to 20 bytes which is the minimum required length for 80-bit security.
\end{itemize}

The SEQ NR is a 32-bit counter so that it will not be likely that there is wrap-around in a single session. The duration of the session obviously depends on the size of the packet as well. If a 1000 bytes frame would be used, this would correspond to a duration of 0.26 seconds. Using a 32-bit counter would then correspond to a session duration of several days. The maximum size of the sequence number is recommended to be 32-bit as it is the maximum workable word size most counters operate on. A bigger sequence number would require a double which would make the code more bulky and the performance less efficient as every time 2 words need to be fetched.\\

We note that it might be possible that we will not even need the length field at all. If the speech buffer is always full when we send the packet, the length will be constant and the receiving side can use this information. In this situation, the packet rate is not constant. However, if the data length is variable (for example because we send packets at a constant rate, regardless of whether or not we have a full buffer), the length field will be required to signal to the receiver how much data is present in the packet.

\end{document}