\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{anysize}
\usepackage{hyperref}
\usepackage{SIunits}
\usepackage{color}

\marginsize{2.5cm}{2.5cm}{1.5cm}{1.5cm}
\setlength{\parindent}{0pt}

\graphicspath{{./images/}}

\title{P\&D Encryption---Phase Two}
\author{Pieter Maene en Stijn Meul}
\date{\today}

\begin{document}
\maketitle

\section{Key Exchange and Authentication}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & SEQ NR & KEY & SIGNATURE \\ \hline
            1B & 4B & 256B & 20B \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Key Exchange Packet}
    \label{tab:key_exchange_packet}
\end{table}

\section{Protocol Messages}
In the Station-to-Station protocol 3 messages will be exchanged between the two DSPs:

\begin{enumerate}
 \item DSP A generates a random number x and then sends $\alpha^x mod p$ to DSP B. This is shown in \ref{tab:key_exchange_packet_senderhello}.
 \item DSP B generates a random number y and sends $\alpha^y mod p$ to DSP A. B signs the concatenation of both exponentials by calculating the HMAC based on the asymmetric key of B. This is shown in \ref{tab:key_exchange_packet_receiverhello}.
 \item DSP A acknowledges the message from DSP B by sending $\alpha^y mod p$ to DSP B. This message is again signed by the concatenation of both exponentials by calculating the HMAC based on the asymmetric key of A. This is shown in \ref{tab:key_exchange_packet_senderacknowledge}.
\end{enumerate}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & KEY & SIGNATURE \\ \hline
            0x00 & $\alpha^x mod p$ & \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Key Exchange Packet -- SenderHello}
    \label{tab:key_exchange_packet_senderhello}
\end{table}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & KEY & SIGNATURE \\ \hline
            0x01 & $\alpha^y mod p$ & HMAC($\alpha^y \big| \alpha^x$)\\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Key Exchange Packet -- ReceiverHello}
    \label{tab:key_exchange_packet_receiverhello}
\end{table}
\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & KEY & SIGNATURE \\ \hline
            0x02 & $\alpha^y mod p$ & HMAC($\alpha^x \big| \alpha^y$)\\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Key Exchange Packet -- SenderAcknowledge}
    \label{tab:key_exchange_packet_senderacknowledge}
\end{table}

\section{Key Derivation}

The result of the STS function is a very long key. The length of this key will be 2048 bit. To shorten this key with enough randomness, it is used as the input of a hash function. The result of the hash function is then truncated to obtain a shorter more useable key.\\

SHA-3 will be used for the Hash function. The resulting keys will consequently be 512 or 1024 bits long. For performance reasons the 512 bit version is prefered. This 512 bit key is then split in four equal parts of 128 bits. The first 128 bits sequence corresponds to the first key. The second 128 bits sequence corresponds to the second key.\\

The first key can then be used as the input for the AES encryption algorithm while the second key is used as the key for the keyed hashfunction for generation of the MAC. The reason to use different keys for the encryption and the MAC is to avoid correlation between these parts of the packet.

\section{Confidentiality and Integrity}

\subsection{Cipher Mode}

The performance of several AES modes is listed on the following page: \url{http://www.cryptopp.com/benchmarks.html}. These processors are not the DSPs we are going to use are not the ones mentioned on the benchmark page, but it gives an idea which algorithm has an intrinsic better performance. From this data and what we learned during the previous phase, we decided to use the CTR mode because it's the fastest. The set-up and IV initialisation times are a bit longer than for other modes, but this is not really a problem: the IV initilisation (which has to be redone for every packet) is neglible in this time. This means we the main drawback is that we will have a setup penalty on the order on one {\micro\second} for each session.\\

We decided on 128-bit keys because this is the smallest length defined by the NIST standard and is still higher than our required security level of 80 bits.

\subsection{HMAC}

We use to following formula to calculate the HMAC.

\subsubsection{Hash Function}



\subsection{Data Packet}

\begin{table}[H]
    \begin{center}
        \begin{tabular}{| c | c | c | c | c |}
            \hline
            TAG & SEQ NR & LENGTH & DATA & HMAC \\ \hline
            1B (1) & 4B & 2B & (2) & 20B (3) \\
            \hline
        \end{tabular}
    \end{center}
    
    \caption{Data Packet}
    \label{tab:data_packet}
\end{table}

\begin{itemize}
  \item (2) The length depends on what the speech groups tell us. The larger the packet, the bigger the influence of a dropped packet on the received audio, so this is a limiting factor. A good reference is the size of an Ethernet frame, which is 1500 bytes (for the entire packet).
  \item (3) For the HMAC, we will calculate the keyed hash of the entire packet (except for the HMAC field itself, of course). We will use a keyed SHA-3 hash here as well, truncated to 20 bytes which is the minimum required length for 80-bit security.
\end{itemize}

The SEQ NR is a 32-bit counter so that it will not be likely that there is wrap-around in a single session. The duration of the session obviously depends on the length of the complete packet as well. If a 1000 bytes frame would be used, this would correspond to a duration of 0.26 seconds. Using a 32-bit counter would then correspond to a session duration of several days. The maximum size of the sequence number is recommended to be 32-bit as it is the maximum workable word size to create counters in. A bigger sequence number would require a double which would make the code more bulky and the performance less efficient as every time 2 words need to be fetched.\\

We note that it might be possible that we will not even need the length field at all. If the speech buffer is always full when we send the packet, the length will be constant and the receiving side can use this information. In this situation, the packet rate is not constant. However, if the data length is variable (for example because we send packets at a constant rate, regardless of whether or not we have a full buffer), the length field will be required to signal to the receiver how much data is present in the packet.

\end{document}